# 2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.
# input : 첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)
# output : 첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.
# 점화식 : D(n) = D(n-2) + D(n-1)

############# 결과분석 #############
# 1. 재귀함수보다 반복문을 사용했을 때 메모리가 절약되었다.
# 2. 근데 유투브에서는 왜 굳이 재귀함수로 DP를 풀었을까? 그냥 재귀함수를 설명하려고?
#   > https://kldp.org/node/134556
#   > 1.알고리즘을 기술한 그대로 코드로 표현된다는 점입니다. 점화식 스타일이나 분할정복 모두 자연스럽게 표현됩니다. 즉, 당연히 가독성이 높아집니다.
#   >   일반적으로 재귀로 구한 코드는 스택을 소비하기 때문에 루프보다 느립니다. (꼬리재귀 등으로 회피할 수 있습니다)
#   >   실제로는 재귀로 확인하고, 루프로 변환하기도 한다.
#   > 2. 변수 사용을 줄일 수 있다. <컴파일러>
#   >   mutable state가 취할 수 있는 가능한 경우의 수를 줄여줍니다.
#   >   결과적으로 프로그램에 오류가 생길 (즉, 잘못된 state로 전이할) 가능성이 줄어들고,
#   >   프로그램이 맞다는 것을 확인(특수한 경우에는 증명)하기가 쉬워집니다.
#


###############################################################
# 1. 재귀함수 : 29104kb	60ms
###############################################################
n = int(input())
tmp = [0 for i in range(n)]

def reculsive(n):
    global tmp
    if n == 1:
        tmp[0] = 1
        return 1
    elif n == 2:
        tmp[1] = 2
        return 2
    elif tmp[n - 1] != 0:
        return tmp[n - 1]
    else:
        tmp[n - 1] = reculsive(n - 2) + reculsive(n - 1)
        return tmp[n - 1]

print(reculsive(n) % 10007)


###############################################################
# 2. 반목문 : 29056kb	60ms
###############################################################
n = int(input())

dp = [0 for _ in range(n+1)]
dp[1] = 1
dp[0] = 1

for i in range(2, n+1):
    dp[i] = dp[i-1] + dp[i-2]

print(dp[n]%10007)


###############################################################
# 3. 재귀함수(배열부분 더 직관적으로 / 첫코드) : 29104kb	60ms
###############################################################
n = int(input())
tmp = [ 0 for i in range(n+1)]  #tmp[0]은 그냥 0으로 비워두자.


def reculsive(n):
    global tmp

    if n == 1:
        tmp[1] = 1
        # print(f'1의 {n} : {tmp}')
        return 1

    elif n == 2:
        tmp[2] = 2
        # print(f'2의 {n} : {tmp}')
        return 2

    elif tmp[n] != 0:
        return tmp[n]

    else :
        tmp[n] = reculsive(n-2) + reculsive(n-1)
        # print(f'\nelse의 {n} : {tmp}')
        return tmp[n] % 10007


print(reculsive(n))
#print(tmp)